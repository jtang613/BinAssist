#!/usr/bin/env python3

from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional, Union


class NodeType(str, Enum):
    """
    Types of nodes in the Binary Knowledge Graph.

    The graph uses a 4-level semantic hierarchy:
    - Level 0: FUNCTION - Complete functions with decompiled code + summaries
    - Level 1: MODULE - Communities of related functions (Leiden-detected)
    - Level 1: COMMUNITY - Detected community grouping
    - Level 2: BINARY - Overall binary summary
    """

    # Complete function with decompiled code and summary
    # Primary unit of analysis for most queries
    FUNCTION = "FUNCTION"

    # Community/module of related functions detected via Leiden algorithm
    # Represents subsystems and logical groupings
    MODULE = "MODULE"

    # Detected community grouping of related functions
    # Same level as MODULE - represents functional groupings
    COMMUNITY = "COMMUNITY"

    # Top-level binary summary
    # Overall program semantics and attack surface
    BINARY = "BINARY"

    @classmethod
    def from_string(cls, value: str) -> Optional["NodeType"]:
        """Parse a node type from its string representation."""
        if value is None:
            return None
        try:
            return cls(value.upper())
        except ValueError:
            return None

    def get_level(self) -> int:
        """Get the hierarchy level (0 = finest, 2 = coarsest)."""
        if self == NodeType.FUNCTION:
            return 0
        elif self in {NodeType.MODULE, NodeType.COMMUNITY}:
            return 1
        elif self == NodeType.BINARY:
            return 2
        return 0

    def is_finer_than(self, other: "NodeType") -> bool:
        """Check if this node type is at a finer granularity than another."""
        return self.get_level() < other.get_level()

    def is_coarser_than(self, other: "NodeType") -> bool:
        """Check if this node type is at a coarser granularity than another."""
        return self.get_level() > other.get_level()


class EdgeType(str, Enum):
    """
    Types of edges in the Binary Knowledge Graph.

    Edges are categorized into four groups:
    - STRUCTURAL: Derived from Binary Ninja analysis (call graph, xrefs, hierarchy)
    - SEMANTIC: Generated by LLM (similarity, logical dependencies)
    - SECURITY: Generated by security analysis (taint, vulnerabilities, network)
    - COMMUNITY: Computed by community detection algorithms
    """

    # ========================================
    # STRUCTURAL edges (from Binary Ninja)
    # ========================================

    # Hierarchical containment (binary → module → function → block)
    CONTAINS = "contains"

    # Function call relationship (caller → callee)
    CALLS = "calls"

    # Control flow between basic blocks
    FLOWS_TO = "flows_to"

    # Cross-references (code referencing data or other code)
    REFERENCES = "references"

    # Type/class inheritance relationships
    INHERITS = "inherits"

    # NOTE: DATA_DEPENDS removed - too noisy for practical use

    # ========================================
    # SEMANTIC edges (LLM-generated)
    # ========================================

    # Functions with similar semantic purpose (undirected)
    SIMILAR_PURPOSE = "similar_purpose"

    # Logical dependency between components
    DEPENDS_ON = "depends_on"

    # Function implements a specific concept
    IMPLEMENTS = "implements"

    # Related functionality without direct call relationship (undirected)
    RELATED_TO = "related_to"

    # ========================================
    # SECURITY edges (analysis-derived)
    # ========================================

    # Security relationship - potential vulnerability path
    VULNERABLE_VIA = "vulnerable_via"

    # Taint propagation path (source → sink)
    TAINT_FLOWS_TO = "taint_flows_to"

    # One node calls or uses a vulnerable function
    CALLS_VULNERABLE = "calls_vulnerable"

    # Network send edge - connection from caller to network send API
    # Represents data flow paths to network output (send, WSASend, etc.)
    NETWORK_SEND = "network_send"

    # Network recv edge - connection from network recv API to caller
    # Represents data flow paths from network input (recv, WSARecv, etc.)
    NETWORK_RECV = "network_recv"

    # ========================================
    # COMMUNITY edges (computed)
    # ========================================

    # Node belongs to a community/module cluster
    BELONGS_TO_COMMUNITY = "belongs_to_community"

    # Nodes that are siblings within the same community (undirected)
    SIBLING = "sibling"

    @classmethod
    def from_string(cls, value: str) -> Optional["EdgeType"]:
        """Parse an edge type from its string representation."""
        if value is None:
            return None
        try:
            return cls(value.lower())
        except ValueError:
            return None

    def is_structural(self) -> bool:
        """Check if this is a structural edge derived from Binary Ninja."""
        return self in {
            EdgeType.CONTAINS, EdgeType.CALLS, EdgeType.FLOWS_TO,
            EdgeType.REFERENCES, EdgeType.INHERITS
        }

    def is_semantic(self) -> bool:
        """Check if this is a semantic edge generated by LLM."""
        return self in {
            EdgeType.SIMILAR_PURPOSE, EdgeType.DEPENDS_ON,
            EdgeType.IMPLEMENTS, EdgeType.RELATED_TO
        }

    def is_security(self) -> bool:
        """Check if this is a security-related edge."""
        return self in {
            EdgeType.VULNERABLE_VIA, EdgeType.TAINT_FLOWS_TO,
            EdgeType.CALLS_VULNERABLE, EdgeType.NETWORK_SEND,
            EdgeType.NETWORK_RECV
        }

    def is_community(self) -> bool:
        """Check if this is a community/clustering edge."""
        return self in {
            EdgeType.BELONGS_TO_COMMUNITY, EdgeType.SIBLING
        }

    def is_directed(self) -> bool:
        """Check if this edge type is directed."""
        # Undirected edges
        if self in {EdgeType.SIMILAR_PURPOSE, EdgeType.RELATED_TO, EdgeType.SIBLING}:
            return False
        return True


@dataclass
class GraphNode:
    id: Optional[str] = None
    binary_hash: str = ""
    node_type: Union[NodeType, str] = NodeType.FUNCTION
    address: Optional[int] = None
    name: Optional[str] = None
    raw_code: Optional[str] = None
    llm_summary: Optional[str] = None
    confidence: float = 0.0
    embedding: Optional[bytes] = None
    security_flags: List[str] = field(default_factory=list)
    network_apis: List[str] = field(default_factory=list)
    file_io_apis: List[str] = field(default_factory=list)
    ip_addresses: List[str] = field(default_factory=list)
    urls: List[str] = field(default_factory=list)
    file_paths: List[str] = field(default_factory=list)
    domains: List[str] = field(default_factory=list)
    registry_keys: List[str] = field(default_factory=list)
    activity_profile: Optional[str] = None
    risk_level: Optional[str] = None
    analysis_depth: int = 0
    is_stale: bool = True
    user_edited: bool = False
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

    def get_node_type(self) -> Optional[NodeType]:
        """Get the node type as a NodeType enum."""
        if isinstance(self.node_type, NodeType):
            return self.node_type
        return NodeType.from_string(self.node_type)

    def get_node_type_str(self) -> str:
        """Get the node type as a string (for database storage)."""
        if isinstance(self.node_type, NodeType):
            return self.node_type.value
        return self.node_type


@dataclass
class GraphEdge:
    id: Optional[str] = None
    binary_hash: str = ""
    source_id: str = ""
    target_id: str = ""
    edge_type: Union[EdgeType, str] = ""
    weight: float = 1.0
    metadata: Optional[str] = None
    created_at: Optional[str] = None

    def get_edge_type(self) -> Optional[EdgeType]:
        """Get the edge type as an EdgeType enum."""
        if isinstance(self.edge_type, EdgeType):
            return self.edge_type
        return EdgeType.from_string(self.edge_type)

    def get_edge_type_str(self) -> str:
        """Get the edge type as a string (for database storage)."""
        if isinstance(self.edge_type, EdgeType):
            return self.edge_type.value
        return self.edge_type
